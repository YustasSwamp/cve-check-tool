/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <nica.h>
#include <openssl/sha.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>
#include <zlib.h>

#include "util.h"

#define STANDARD_BUFER_SIZE 8192

bool cve_gunzip_file(const char *path, const char *out_path, mode_t mode)
{
        char buffer[STANDARD_BUFER_SIZE] = { 0 };
        gzFile gzfile = NULL;
        int out_fd;
        int r;
        bool ret = false;

        gzfile = gzopen(path, "rb");
        if (!gzfile) {
                fprintf(stderr, "cve_gunzip_file(): %s %s\n", path, strerror(errno));
                return false;
        }

        out_fd = open(out_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        if (out_fd <= 0) {
                fprintf(stderr, "cve_gunzip_file(): %s %s\n", out_path, strerror(errno));
                goto clean;
        }

        while ((r = gzread(gzfile, buffer, sizeof(buffer))) > 0) {
                if (write(out_fd, buffer, r) != r) {
                        fprintf(stderr, "cve_gunzip_file(): File write failed\n");
                        goto clean;
                }
        }

        ret = true;
clean:
        if (gzfile) {
                gzclose(gzfile);
        }
        if (out_fd > 0) {
                close(out_fd);
        }
        return ret;
}

char *cve_get_sha256sum(const char *path)
{
        char hex[SHA256_DIGEST_LENGTH * 2 + 1] = { 0 };
        unsigned char sha[SHA256_DIGEST_LENGTH] = { 0 };
        autofree(CveMappedFile) *m_file = CVE_MAPPED_FILE_INIT;
        SHA256_CTX ctx = { 0 };

        if (!cve_mapped_file_open(path, m_file)) {
                fprintf(stderr, "cve_get_sha256sum(): %s %s\n", path, strerror(errno));
                return NULL;
        }

        SHA256_Init(&ctx);
        SHA256_Update(&ctx, m_file->buffer, m_file->length);
        if (!SHA256_Final(sha, &ctx)) {
                fprintf(stderr, "cve_get_sha256sum(): failed to get hash: %s\n", path);
                return NULL;
        }

        for (size_t i = 0; i < sizeof(sha); i++) {
                size_t idx = i * 2;
                size_t len = sizeof(hex) - idx;

                snprintf(&hex[idx], len, "%02hhx", sha[i]);
        }

        return strdup(hex);
}

/**
 * Very losely based on the libnica inifile parser, to suit situations
 * where everyone needs their own INI-Like format. Like the NVD...
 * Nica INI Parser obeys the spec and requires [Section]s, hence this
 * bit of duplication
 */
NcHashmap *cve_parse_delim_file(const char *path, char sep)
{
        autofree(FILE) *inp = NULL;
        char *buf = NULL;
        ssize_t rd = 0;
        size_t sn = 0;
        NcHashmap *map = NULL;

        inp = fopen(path, "r");
        if (!inp) {
                fprintf(stderr, "cve_parse_delim_file(): %s %s\n", path, strerror(errno));
                return NULL;
        }

        map = nc_hashmap_new_full(nc_string_hash, nc_string_compare, free, free);

        while ((rd = getline(&buf, &sn, inp)) > 0) {
                /* Fix newline */
                if (buf[rd - 1] == '\n') {
                        buf[rd - 1] = '\0';
                        --rd;
                }

                if (streq(buf, "")) {
                        continue;
                }

                /* Basic comment handling. See libnica's inifile.c for a more
                 * complete delimfile parser
                 */
                if (buf[0] == '#') {
                        continue;
                }

                char *r = strchr(buf, sep);
                if (!r) {
                        continue;
                }
                int len = r - buf;

                if (len + 1 >= rd) {
                        continue;
                }

                buf[len] = '\0';
                char *left = strdup(buf);
                char *right = strdup(r + 1);

                if (!left || !right) {
                        fprintf(stderr, "Out of memory\n");
                        return NULL;
                }

                if (!nc_hashmap_put(map, left, right)) {
                        fprintf(stderr, "Out of memory\n");
                        nc_hashmap_free(map);
                        free(left);
                        free(right);
                        return NULL;
                }

                if (buf) {
                        free(buf);
                        buf = NULL;
                }
        }
        if (buf) {
                free(buf);
        }
        return map;
}

char *cve_file_get_text(const char *path)
{
        autofree(CveMappedFile) *file = CVE_MAPPED_FILE_INIT;

        if (!cve_mapped_file_open(path, file)) {
                return NULL;
        }
        return strdup(file->buffer);
}

bool cve_mapped_file_open(const char *path, CveMappedFile *file)
{
        if (!file) {
                return false;
        }
        int fd = -1;
        struct stat st = { 0 };
        size_t length = -1;
        char *buffer = NULL;

        fd = open(path, O_RDONLY);
        if (fd < 0) {
                return false;
        }
        if (fstat(fd, &st) != 0) {
                close(fd);
                return false;
        }
        length = st.st_size;

        buffer = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, 0);
        if (!buffer) {
                close(fd);
                return false;
        }
        file->length = length;
        file->buffer = buffer;
        file->fd = fd;
        return true;
}

void cve_mapped_file_close(CveMappedFile *file)
{
        if (!file) {
                return;
        }
        munmap(file->buffer, file->length);
        close(file->fd);
        memset(file, 0, sizeof(CveMappedFile));
}

int64_t parse_iso8601_date(const char *date)
{
        char tzchar = 0;
        int tzhour, tzmin = -1;
        int tzoffset = 0;
        struct tm tm = { 0 };
        time_t ret_time = -1;
        /* deliberately drop extra precision later */
        float seconds = -1;

        if (sscanf(date,
                   "%4d-%2d-%2dT%2d:%2d:%g%c%2d:%2d",
                   &tm.tm_year,
                   &tm.tm_mon,
                   &tm.tm_mday,
                   &tm.tm_hour,
                   &tm.tm_min,
                   &seconds,
                   &tzchar,
                   &tzhour,
                   &tzmin) != 9) {
                return -1;
        }

        tm.tm_year -= 1900;
        tm.tm_mon--;
        tm.tm_sec = (int)seconds;

        if (tzhour > 0) {
                tzoffset = (60 * 60) * tzhour;
        }
        if (tzmin > 0) {
                tzoffset += 60 * tzmin;
        }

        ret_time = mktime(&tm);
        if (tzchar == '+') {
                tzoffset = -(tzoffset);
        } else if (tzchar != '-') {
                return -1;
        }
        return ret_time + tzoffset;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
