/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <nica.h>
#include <openssl/sha.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <time.h>
#include <zlib.h>

#include "util.h"

#define STANDARD_BUFER_SIZE 8192

bool cve_gunzip_file(const char *path, const char *out_path, mode_t mode)
{
        char buffer[STANDARD_BUFER_SIZE] = { 0 };
        gzFile gzfile = NULL;
        int out_fd;
        int r;
        bool ret = false;

        gzfile = gzopen(path, "rb");
        if (!gzfile) {
                fprintf(stderr, "cve_gunzip_file(): %s %s\n", path, strerror(errno));
                return false;
        }

        out_fd = open(out_path, O_WRONLY | O_CREAT | O_TRUNC, mode);
        if (out_fd <= 0) {
                fprintf(stderr, "cve_gunzip_file(): %s %s\n", out_path, strerror(errno));
                goto clean;
        }

        while ((r = gzread(gzfile, buffer, sizeof(buffer))) > 0) {
                if (write(out_fd, buffer, r) != r) {
                        fprintf(stderr, "cve_gunzip_file(): File write failed\n");
                        goto clean;
                }
        }

        ret = true;
clean:
        if (gzfile) {
                gzclose(gzfile);
        }
        if (out_fd > 0) {
                close(out_fd);
        }
        return ret;
}

char *cve_get_sha256sum(const char *path)
{
        char hex[SHA256_DIGEST_LENGTH * 2 + 1] = { 0 };
        unsigned char sha[SHA256_DIGEST_LENGTH] = { 0 };
        char buffer[STANDARD_BUFER_SIZE] = { 0 };
        SHA256_CTX ctx = { 0 };
        int fd;
        int r;
        char *ret = NULL;

        fd = open(path, O_RDONLY);
        if (fd <= 0) {
                fprintf(stderr, "cve_get_sha256sum(): %s %s\n", path, strerror(errno));
                return NULL;
        }

        SHA256_Init(&ctx);

        while ((r = read(fd, buffer, sizeof(buffer))) > 0) {
                SHA256_Update(&ctx, buffer, r);
        }
        if (r < 0) {
                fprintf(stderr, "cve_get_sha256sum(): %s %s\n", path, strerror(errno));
                goto clean;
        }

        SHA256_Final(sha, &ctx);

        for (size_t i = 0; i < sizeof(sha); i++) {
                size_t idx = i * 2;
                size_t len = sizeof(hex) - idx;

                snprintf(&hex[idx], len, "%02hhx", sha[i]);
        }

        ret = strdup(hex);
clean:
        close(fd);
        return ret;
}

/**
 * Very losely based on the libnica inifile parser, to suit situations
 * where everyone needs their own INI-Like format. Like the NVD...
 * Nica INI Parser obeys the spec and requires [Section]s, hence this
 * bit of duplication
 */
NcHashmap *cve_parse_delim_file(const char *path, char sep)
{
        autofree(FILE) *inp = NULL;
        char *buf = NULL;
        ssize_t rd = 0;
        size_t sn = 0;
        NcHashmap *map = NULL;

        inp = fopen(path, "r");
        if (!inp) {
                fprintf(stderr, "cve_parse_delim_file(): %s %s\n", path, strerror(errno));
                return NULL;
        }

        map = nc_hashmap_new_full(nc_string_hash, nc_string_compare, free, free);

        while ((rd = getline(&buf, &sn, inp)) > 0) {
                /* Fix newline */
                if (buf[rd - 1] == '\n') {
                        buf[rd - 1] = '\0';
                        --rd;
                }

                if (streq(buf, "")) {
                        continue;
                }

                /* Basic comment handling. See libnica's inifile.c for a more
                 * complete delimfile parser
                 */
                if (buf[0] == '#') {
                        continue;
                }

                char *r = strchr(buf, sep);
                if (!r) {
                        continue;
                }
                int len = r - buf;

                if (len + 1 >= rd) {
                        continue;
                }

                buf[len] = '\0';
                char *left = strdup(buf);
                char *right = strdup(r + 1);

                if (!left || !right) {
                        fprintf(stderr, "Out of memory\n");
                        return NULL;
                }

                if (!nc_hashmap_put(map, left, right)) {
                        fprintf(stderr, "Out of memory\n");
                        nc_hashmap_free(map);
                        free(left);
                        free(right);
                        return NULL;
                }

                if (buf) {
                        free(buf);
                        buf = NULL;
                }
        }
        if (buf) {
                free(buf);
        }
        return map;
}

char *cve_file_get_text(const char *path)
{
        char *buffer = NULL;
        int fd = -1;
        struct stat st = { 0 };
        size_t length = -1;
        char *copy = NULL;

        fd = open(path, O_RDONLY);
        if (fd <= 0) {
                return NULL;
        }
        if (fstat(fd, &st) != 0) {
                close(fd);
                return NULL;
        }
        length = st.st_size;

        buffer = mmap(NULL, length, PROT_READ, MAP_PRIVATE, fd, 0);
        copy = strdup(buffer);
        munmap(buffer, length);
        close(fd);
        return copy;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
