/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * As an additional permission, the right to link to OpenSSL is granted.
 */

#define _GNU_SOURCE

#include <nica.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "template.h"

/**
 * Represents the current node type in the parse context, when a full
 * node has been found.
 */
typedef enum {
        NC_TMPL_NODE_ROOT = 0,        /**<Root node of all contexts */
        NC_TMPL_NODE_SECTION,         /**<Section/conditionals, # start */
        NC_TMPL_NODE_SECTION_END,     /**<End of a section, "/" start */
        NC_TMPL_NODE_INVERSE_SECTION, /**<Begin inverse section, "^" start */
        NC_TMPL_NODE_COMMENT,         /**<Begin comment, "!" start */
        NC_TMPL_NODE_VARIABLE,        /**<Default node type, substitution var */
} NcTemplateNodeType;

typedef struct NcTemplateNode {
        char *tag;       /**<Name of this token */
        size_t tag_len;  /**<Length of this tag */
        char *lead;      /**<Any text between this token and the end/next token */
        size_t lead_len; /**<Length of the lead text */
        char *tail;
        size_t tail_len;
        NcTemplateNodeType ntype;      /**<Type of this particular node */
        struct NcTemplateNode *parent; /**<Parent of this node for context resolution */
        struct NcTemplateNode *next;   /**<Sibling in current node heirarchy */
        struct NcTemplateNode *child;  /**<Child (subcontext) of this current context */
} NcTemplateNode;

/**
 * Instance tracking
 */
struct NcTemplateParser {
        NcTemplateNode *root_node;
};

/**
 * Context data
 */
struct NcTemplateContext {
        NcHashmap *store;
        struct NcTemplateContext *parent;
};

/**
 * Possible types for an NcTemplateValue
 */
typedef enum {
        NC_TMPL_VALUE_MIN = 0,
        NC_TMPL_VALUE_STRING,
        NC_TMPL_VALUE_BOOL,
        NC_TMPL_VALUE_CHILD,
        NC_TMPL_VALUE_LIST,
        NC_TMPL_VALUE_MAX
} NcTemplateValueType;

/**
 * NcTemplateValue wraps various value types for a template context
 */
typedef struct NcTemplateValue {
        NcTemplateValueType vtype; /**<Type for this context variable */
        void *value;               /**<Value for this context variable */
} NcTemplateValue;

/**
 * Construct a new NcTemplateValue
 */
static inline NcTemplateValue *nc_template_value_new(NcTemplateValueType vtype, void *value)
{
        NcTemplateValue *ret = NULL;

        if (vtype < NC_TMPL_VALUE_MIN || vtype >= NC_TMPL_VALUE_MAX) {
                return NULL;
        }

        ret = calloc(1, sizeof(struct NcTemplateValue));
        if (!ret) {
                return NULL;
        }
        ret->vtype = vtype;
        ret->value = value;
        return ret;
}

/**
 * Free a previously allocated NcTemplateValue
 */
static inline void nc_template_value_free(NcTemplateValue *self)
{
        NcList *list, *elem = NULL;

        if (!self) {
                return;
        }
        switch (self->vtype) {
        case NC_TMPL_VALUE_STRING:
                free(self->value);
                break;
        case NC_TMPL_VALUE_CHILD:
                nc_template_context_free((NcTemplateContext *)self->value);
                break;
        case NC_TMPL_VALUE_LIST:
                list = self->value;
                NC_LIST_FOREACH (list, elem) {
                        nc_template_context_free((NcTemplateContext *)elem->data);
                }
                nc_list_free(&list);
                break;
        default:
                break;
        }
        free(self);
}

/**
 * Template context functions
 */
NcTemplateContext *nc_template_context_new(void)
{
        NcTemplateContext *ret = NULL;

        ret = calloc(1, sizeof(struct NcTemplateContext));

        if (!ret) {
                return NULL;
        }
        ret->store = nc_hashmap_new_full(nc_string_hash,
                                         nc_string_compare,
                                         free,
                                         (nc_hash_free_func)nc_template_value_free);
        if (!ret->store) {
                nc_template_context_free(ret);
                return NULL;
        }
        return ret;
}

void nc_template_context_free(NcTemplateContext *self)
{
        if (!self) {
                return;
        }
        nc_hashmap_free(self->store);
        free(self);
}

bool nc_template_context_add_value(NcTemplateContext *self, const char *key,
                                   NcTemplateValueType vtype, void *value)
{
        NcTemplateValue *val = NULL;
        char *key_dup = strdup(key);

        if (!key_dup) {
                return false;
        }

        val = nc_template_value_new(vtype, value);
        if (!val) {
                return false;
        }
        /* Assign parent to child nodes */
        if (value && vtype == NC_TMPL_VALUE_CHILD) {
                ((NcTemplateContext *)value)->parent = self;
        }
        return nc_hashmap_put(self->store, key_dup, val);
}

bool nc_template_context_add_string(NcTemplateContext *self, const char *key, char *value)
{
        char *dup = strdup(value);

        if (!dup) {
                return false;
        }

        if (!nc_template_context_add_value(self, key, NC_TMPL_VALUE_STRING, dup)) {
                free(dup);
                return false;
        }
        return true;
}

bool nc_template_context_add_bool(NcTemplateContext *self, const char *key, bool value)
{
        return nc_template_context_add_value(self, key, NC_TMPL_VALUE_BOOL, NC_HASH_VALUE(value));
}

bool nc_template_context_add_child(NcTemplateContext *self, const char *key,
                                   NcTemplateContext *child)
{
        if (!child) {
                return false;
        }
        return nc_template_context_add_value(self, key, NC_TMPL_VALUE_CHILD, child);
}

bool nc_template_context_add_list(NcTemplateContext *self, const char *key, NcTemplateContext *node)
{
        NcList *list = NULL;
        NcTemplateValue *value = NULL;

        value = nc_hashmap_get(self->store, key);
        if (value) {
                if (value->vtype != NC_TMPL_VALUE_LIST) {
                        fprintf(stderr, "Attempted to add list to type that isn't a list.\n");
                        return false;
                }
                list = value->value;
                if (!nc_list_append(&list, node)) {
                        return false;
                }
        } else {
                if (!nc_list_append(&list, node)) {
                        return false;
                }
                node->parent = self;
                return nc_template_context_add_value(self, key, NC_TMPL_VALUE_LIST, list);
        }
        return true;
}

/**
 * Search for a value in the current context first, and if it isn't found,
 * reverse the tree until we do find it, or return NULL
 */
NcTemplateValue *nc_template_context_search_value(NcTemplateContext *self, const char *key)
{
        if (!self || !self->store) {
                abort();
        }
        NcTemplateContext *ctx = self;
        NcTemplateValue *val = NULL;

        while (ctx) {
                val = nc_hashmap_get(ctx->store, key);
                if (val) {
                        return val;
                }
                ctx = ctx->parent;
        }
        return NULL;
}

/**
 * Internal functions
 */
bool nc_template_render(NcTemplateNode *root_node, NcTemplateContext *context, FILE *stream);
void nc_template_node_free(NcTemplateNode *root);

NcTemplateParser *nc_template_parser_new()
{
        NcTemplateParser *p = NULL;

        p = calloc(1, sizeof(struct NcTemplateParser));
        return p;
}

static inline void nc_template_parser_reset(NcTemplateParser *parser)
{
        nc_template_node_free(parser->root_node);
        parser->root_node = NULL;
}

void nc_template_parser_free(NcTemplateParser *parser)
{
        if (!parser) {
                return;
        }
        nc_template_parser_reset(parser);
        free(parser);
}

/**
 * Construct a new NcTemplateNode with the given tag and type
 */
NcTemplateNode *nc_template_node_new(char *tag, NcTemplateNodeType ntype)
{
        NcTemplateNode *ret = NULL;

        ret = calloc(1, sizeof(NcTemplateNode));
        if (!ret) {
                /* FIXME */
                abort();
        }
        ret->tag = tag;
        ret->ntype = ntype;
        return ret;
}

/**
 * Free a previously allocated NcTemplateNode
 */
void nc_template_node_free(NcTemplateNode *root)
{
        if (!root) {
                return;
        }
        nc_template_node_free(root->child);
        nc_template_node_free(root->next);

        free(root->tag);
        free(root);
}

/**
 * Traverse the node to find the last element
 */
__attribute__((always_inline)) static inline NcTemplateNode *nc_template_node_last(
    NcTemplateNode *node)
{
        NcTemplateNode *n = node;
        NcTemplateNode *p = NULL;

        while (n) {
                p = n->next;
                if (!p) {
                        return n;
                }
                n = p;
        }
        return n;
}

/**
 * Factory function which will disappear in future.
 */
__attribute__((always_inline)) static inline NcTemplateNode *nc_template_node_from_tag(
    char *tag, size_t tag_len)
{
        switch (tag[0]) {
        case '#':
                return nc_template_node_new(strndup(tag + 1, --tag_len), NC_TMPL_NODE_SECTION);
        case '^':
                return nc_template_node_new(strndup(tag + 1, --tag_len),
                                            NC_TMPL_NODE_INVERSE_SECTION);
        case '/':
                return nc_template_node_new(strndup(tag + 1, --tag_len), NC_TMPL_NODE_SECTION_END);
        case '!':
                /* This is a comment, skip it. */
                return NULL;
        default:
                return nc_template_node_new(strndup(tag, tag_len), NC_TMPL_NODE_VARIABLE);
        }
}

/**
 * Main parse loop
 */
bool nc_template_parser_load(NcTemplateParser *parser, const char *buffer, ssize_t length)
{
        size_t line_no = 1;
        size_t column = 0;
        size_t start_line_no = 0;
        size_t start_column = 0;
        char start_tags[] = { '{', '{' };
        char end_tags[] = { '}', '}' };

        char *sp_buffer = start_tags;
        char *ep_buffer = end_tags;
        char expected = '\0';
        bool in_tag = false;

        /* So we can dynamically update this later.. */
        size_t sp_buffer_len = 2;
        size_t ep_buffer_len = 2;

        /* Track offsets to buffer, minimize copies. */
        size_t tag_start_offset = -1;
        size_t tag_end_offset = -1;
        ssize_t last_offset = 0;

        NcTemplateNode *root = NULL;
        /* For tracking subcontexts */
        NcTemplateNode *parent = NULL;
        NcTemplateNode *last_sect = NULL;

        if (!parser) {
                return false;
        }

        nc_template_parser_reset(parser);

        /* Need to do something useful with all this. */
        root = nc_template_node_new(NULL, NC_TMPL_NODE_ROOT);
        if (!root) {
                return -1;
        }

        parent = root;

        for (ssize_t i = 0; i < length; i++) {
                char c = buffer[i];

                /* Handle newline reset */
                if (c == '\n') {
                        ++line_no;
                        column = 0;
                        continue;
                }
                ++column;

                /* If we don't get an expected char, reset the state
                 * Avoids situations like: {}{}all text here
                 */
                if (expected && c != expected) {
                        expected = '\0';
                        in_tag = false;
                        tag_start_offset = tag_end_offset = 0;
                        sp_buffer = start_tags;
                        ep_buffer = end_tags;
                        continue;
                }

                if (c == *sp_buffer) {
                        /* Handle start tags */
                        ++sp_buffer;
                        size_t len = sp_buffer - start_tags;
                        if (len != sp_buffer_len) {
                                expected = *sp_buffer;
                                continue;
                        }
                        sp_buffer = start_tags;
                        in_tag = true;
                        tag_start_offset = i;
                        expected = '\0';
                        start_line_no = line_no;
                        start_column = column;
                } else if (c == *ep_buffer) {
                        size_t tag_len;
                        size_t tag_offset;
                        NcTemplateNode *text_node = NULL;
                        bool text_tail = false;
                        bool root_text = root->child == NULL && parent == root;

                        /* Handle end tags */
                        ++ep_buffer;
                        size_t len = ep_buffer - end_tags;
                        if (len != ep_buffer_len) {
                                expected = *ep_buffer;
                                continue;
                        }
                        expected = '\0';
                        ep_buffer = end_tags;

                        /* Could be a stray end tag in the template, just skip it */
                        if (!in_tag) {
                                continue;
                        }

                        /* Cleanup */
                        in_tag = false;
                        tag_end_offset = i;

                        /* Now have a complete tag. */
                        tag_len = (tag_end_offset - tag_start_offset) - (ep_buffer_len);
                        if (tag_len < 1) {
                                fprintf(stderr,
                                        "[L%ld@%ld] Skipping empty tag\n",
                                        start_line_no,
                                        start_column);
                                continue;
                        }

                        tag_offset = tag_start_offset + 1 /* Skip last */;

                        NcTemplateNode *node =
                            nc_template_node_from_tag((char *)buffer + tag_offset, tag_len);
                        if (!node) {
                                goto next;
                        }

                        switch (node->ntype) {
                        case NC_TMPL_NODE_SECTION:
                        case NC_TMPL_NODE_INVERSE_SECTION:
                                if (!parent->child) {
                                        parent->child = node;
                                } else {
                                        text_node = nc_template_node_last(parent->child);
                                        text_node->next = node;
                                }
                                node->parent = parent;
                                last_sect = NULL;
                                parent = node;
                                break;
                        case NC_TMPL_NODE_SECTION_END:
                                if (!parent->tag || !streq(parent->tag, node->tag)) {
                                        if (parent == root) {
                                                fprintf(stderr,
                                                        "[L%ld@%ld] Closed section '%s' without "
                                                        "any opened section\n",
                                                        start_line_no,
                                                        start_column,
                                                        node->tag);
                                        } else {
                                                fprintf(stderr,
                                                        "[L%ld@%ld] Closed section '%s', expected "
                                                        "'%s'\n",
                                                        start_line_no,
                                                        start_column,
                                                        node->tag,
                                                        parent->tag);
                                        }
                                        nc_template_node_free(node);
                                        goto fail;
                                }
                                last_sect = parent;
                                parent = parent->parent;
                                nc_template_node_free(node);
                                node = NULL;
                                break;
                        case NC_TMPL_NODE_VARIABLE:
                                if (!parent->child) {
                                        text_node = parent;
                                        text_tail = true;
                                        parent->child = node;
                                } else {
                                        text_node = nc_template_node_last(parent->child);
                                        text_node->next = node;
                                }
                                node->parent = parent;
                                break;
                        default:
                                assert(node == NULL);
                                break;
                        }

                        /* Closed a section, set the lead */
                        if (!node) {
                                text_node = nc_template_node_last(last_sect->child);
                                if (text_node) {
                                        node = text_node;
                                } else {
                                        node = last_sect;
                                }
                        }

                        if (root_text) {
                                text_node = root;
                                text_tail = true;
                        }
                        if (!text_node) {
                                text_node = node;
                        }

                        size_t lead_start = last_offset;
                        size_t lead_len = (tag_start_offset - lead_start) - 1;

                        if (lead_len > 0) {
                                if (text_tail) {
                                        text_node->lead = (char *)buffer + lead_start;
                                        text_node->lead_len = lead_len;
                                } else {
                                        text_node->tail = (char *)buffer + lead_start;
                                        text_node->tail_len = lead_len;
                                }
                        }
                next:
                        last_offset = tag_end_offset + 1;
                        tag_end_offset = tag_start_offset = -1;
                } else {
                        sp_buffer = start_tags;
                        ep_buffer = end_tags;
                }
        }
        if (parent != root) {
                fprintf(stderr, "Section '%s' was not closed\n", parent->tag);
                goto fail;
        }
        /* Ensure all text is compiled into the template */
        if (last_offset < length) {
                ssize_t diff = length - last_offset;
                root->tail_len = diff;
                root->tail = (char *)buffer + last_offset;
        }

        parser->root_node = root;
        return true;
fail:
        nc_template_node_free(root);

        return false;
}

bool nc_template_render(NcTemplateNode *root, NcTemplateContext *context, FILE *stream)
{
        if (!root) {
                return false;
        }
        bool should_render = false;
        bool render_lead = false;
        NcTemplateValue *svalue = NULL;
        NcTemplateContext *child_context = context;
        NcList *list = NULL;

        if (root->tag) {
                svalue = nc_template_context_search_value(context, root->tag);
        }

        switch (root->ntype) {
        /* Special nodes, always traverse */
        case NC_TMPL_NODE_ROOT:
                if (root->lead) {
                        if (fprintf(stream, "%.*s", (int)root->lead_len, root->lead) < 0) {
                                return false;
                        }
                }
                should_render = true;
                break;
        case NC_TMPL_NODE_VARIABLE:
                if (root->lead) {
                        if (fprintf(stream, "%.*s", (int)root->lead_len, root->lead) < 0) {
                                return false;
                        }
                }
                if (svalue) {
                        if (svalue->vtype == NC_TMPL_VALUE_STRING) {
                                if (fputs(svalue->value, stream) < 0) {
                                        return false;
                                }
                        } else if (svalue->vtype == NC_TMPL_VALUE_BOOL) {
                                if (fprintf(stream, svalue->value ? "true" : "false") < 0) {
                                        return false;
                                }
                        } else if (svalue->vtype == NC_TMPL_VALUE_LIST) {
                                if (fprintf(stream, svalue->value ? "true" : "false") < 0) {
                                        return false;
                                }
                                fprintf(stderr,
                                        "Warning: Variable %s is a list, use in a section\n",
                                        root->tag);
                        } else if (svalue->vtype == NC_TMPL_VALUE_CHILD) {
                                if (fprintf(stream, svalue->value ? "true" : "false") < 0) {
                                        return false;
                                }
                                fprintf(
                                    stderr,
                                    "Warning: Variable %s is a child context, use as a section\n",
                                    root->tag);
                        }
                } /* skip null variable */
                should_render = true;
                break;
        case NC_TMPL_NODE_SECTION:
        case NC_TMPL_NODE_INVERSE_SECTION:
                /* Set up child context if necessary */
                render_lead = true;
                if (svalue) {
                        should_render = true;
                        if (svalue->vtype == NC_TMPL_VALUE_CHILD) {
                                child_context = (NcTemplateContext *)svalue->value;
                        } else if (svalue->vtype == NC_TMPL_VALUE_BOOL) {
                                /* Boolean is basically not-null */
                                if (svalue->value) {
                                        should_render = true;
                                } else {
                                        should_render = false;
                                }
                        } else if (svalue->vtype == NC_TMPL_VALUE_STRING) {
                                /* No key? No section. */
                                if (!svalue->value) {
                                        should_render = false;
                                }
                        } else if (svalue->vtype == NC_TMPL_VALUE_LIST) {
                                list = svalue->value;
                                if (!list) {
                                        should_render = false;
                                } else {
                                        render_lead = false;
                                }
                        }
                }
                if (render_lead) {
                        if (root->lead) {
                                if (fprintf(stream, "%.*s", (int)root->lead_len, root->lead) < 0) {
                                        return false;
                                }
                        }
                }
                /* Invert it again */
                if (root->ntype == NC_TMPL_NODE_INVERSE_SECTION) {
                        should_render = !should_render;
                }
                break;
        default:
                if (root->lead) {
                        if (fprintf(stream, "%.*s", (int)root->lead_len, root->lead) < 0) {
                                return false;
                        }
                }
                should_render = false;
        }

        /* Render with the child context */
        if (should_render) {
                NcList *elem = NULL;
                if (!list) {
                        if (root->child &&
                            !nc_template_render(root->child, child_context, stream)) {
                                return false;
                        }
                } else {
                        /* Re-render the root child node with the given context */
                        NC_LIST_FOREACH (list, elem) {
                                child_context = elem->data;
                                child_context->parent = context;
                                if (root->lead) {
                                        if (fprintf(stream,
                                                    "%.*s",
                                                    (int)root->lead_len,
                                                    root->lead) < 0) {
                                                return false;
                                        }
                                }
                                if (root->child) {
                                        if (!nc_template_render(root->child,
                                                                child_context,
                                                                stream)) {
                                                return false;
                                        }
                                } else {
                                        /* Text-only node with no children */
                                        if (root->tail) {
                                                int r = fprintf(stream,
                                                                "%.*s\n",
                                                                (int)root->tail_len,
                                                                root->tail);
                                                if (r < 0) {
                                                        return false;
                                                }
                                        }
                                        should_render = false;
                                }
                        }
                }
        }

        if (should_render && root->tail) {
                if (fprintf(stream, "%.*s", (int)root->tail_len, root->tail) < 0) {
                        return false;
                }
        }

        /* Render the next guy */
        if (root->next && !nc_template_render(root->next, context, stream)) {
                return false;
        }
        return true;
}

bool nc_template_parser_render(NcTemplateParser *parser, NcTemplateContext *context, FILE *stream)
{
        if (!parser || !parser->root_node) {
                return false;
        }
        return nc_template_render(parser->root_node, context, stream);
}
