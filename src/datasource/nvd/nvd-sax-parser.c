/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE

#include <libxml/SAX2.h>
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#include <malloc.h>
#include <stdbool.h>

#include "nvd.h"

typedef struct NvdSaxParser {
        /** XML traversal state */
        bool in_list;
        bool in_entry;
        bool in_product;
        bool in_summary;
        bool in_reference;

        bool in_link;
        bool in_vuln_cvss;
        bool in_base_metrics;
        bool in_score;
        bool in_vector;
        bool in_date;

        xmlChar *cur_id;
        xmlChar *summary;
        xmlChar *score;
        xmlChar *vector;
        xmlChar *modified;
        NvdCallback callback;
} NvdSaxParser;

/**
 * Ensure XML is properly initialised
 */
__attribute__((constructor)) static void _nvd_init_(void)
{
        LIBXML_TEST_VERSION
}

static void nvd_sax_handle_flip_states(NvdSaxParser *self, const xmlChar *name)
{
        if (xmlStrEqual(name, BAD_CAST "vuln:references")) {
                self->in_link = !self->in_link;
                return;
        }
        if (self->in_link && xmlStrEqual(name, BAD_CAST "vuln:reference")) {
                /* TODO: Handle URIs */
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:vulnerable-software-list")) {
                self->in_list = !self->in_list;
                return;
        }
        if (self->in_list && xmlStrEqual(name, BAD_CAST "vuln:product")) {
                self->in_product = !self->in_product;
                return;
        }
        /* Score checking */
        if (xmlStrEqual(name, BAD_CAST "vuln:cvss")) {
                self->in_vuln_cvss = !self->in_vuln_cvss;
                return;
        }
        if (self->in_vuln_cvss &&
            xmlStrEqual(name, BAD_CAST "cvss:base_metrics")) {
                self->in_base_metrics = !self->in_base_metrics;
                return;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:score")) {
                self->in_score = !self->in_score;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:access-vector")) {
                self->in_vector = !self->in_vector;
        }
        /* Get last modified */
        if (xmlStrEqual(name, BAD_CAST "vuln:last-modified-datetime")) {
                self->in_date = !self->in_date;
        }
        if (self->in_entry && xmlStrEqual(name, BAD_CAST "vuln:summary")) {
                self->in_summary = !self->in_summary;
        }
}

static void nvd_sax_start_element(void *udata, const xmlChar *name,
                                  const xmlChar **attrs)
{
        NvdSaxParser *self = udata;

        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = true;
                if (attrs && attrs[0]) {
                        if (xmlStrEqual(attrs[0], BAD_CAST "id")) {
                                self->cur_id = xmlStrdup(attrs[1]);
                        }
                }
                return;
        }

        if (!self->in_entry) {
                return;
        }

        nvd_sax_handle_flip_states(self, name);
}

static void nvd_sax_clean(NvdSaxParser *self)
{
        xmlFree(self->cur_id);
        self->cur_id = NULL;
        xmlFree(self->summary);
        self->summary = NULL;
        xmlFree(self->vector);
        self->vector = NULL;
        xmlFree(self->score);
        self->score = NULL;
        xmlFree(self->modified);
        self->modified = NULL;
}

static void nvd_sax_end_element(void *udata, const xmlChar *name)
{
        NvdSaxParser *self = udata;
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = false;
                if (!self->callback) {
                        goto next;
                }
                CveProductEntry ent = { 0 };
                ent.cve_id = (const xmlChar *)self->cur_id;
                ent.summary = self->summary;
                ent.vector = self->vector;
                ent.score = self->score;

                /* TODO: Loop products, update ent, emit */
                self->callback(&ent);
        next:
                nvd_sax_clean(self);
                return;
        }
        if (!self->in_entry) {
                return;
        }
        nvd_sax_handle_flip_states(self, name);
}

static void nvd_sax_characters(void *udata, const xmlChar *ch, int len)
{
        NvdSaxParser *self = udata;

        if (self->in_summary) {
                xmlChar *summary = xmlStrndup(ch, len);
                /* Handle multi-line */
                if (self->summary) {
                        char *new = NULL;
                        if (!asprintf(&new, "%s%s", self->summary, summary)) {
                                abort();
                        }
                        free(self->summary);
                        free(summary);
                        self->summary = (xmlChar *)new;
                } else {
                        self->summary = summary;
                }
                return;
        }
        if (self->in_vector) {
                self->vector = xmlStrndup(ch, len);
                return;
        }
        if (self->in_score) {
                self->score = xmlStrndup(ch, len);
                return;
        }
        if (self->in_date) {
                self->modified = xmlStrndup(ch, len);
                return;
        }
}

/**
 * Parse an NVD xml database using SAX2 API
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool nvd_sax_parser_load(const char *fname, NvdCallback callback)
{
        xmlParserCtxtPtr ctx = NULL;
        xmlSAXHandler handler = { 0 };
        NvdSaxParser instance = { 0 };
        xmlDocPtr p = NULL;
        xmlSAXHandler *old = NULL;
        handler.startElement = nvd_sax_start_element;
        handler.endElement = nvd_sax_end_element;
        handler.characters = nvd_sax_characters;
        ctx = xmlCreateFileParserCtxt(fname);
        if (!ctx) {
                fprintf(stderr, "nvd: Error creating XML context\n");
                return false;
        }
        old = ctx->sax;
        ctx->sax = &handler;
        ctx->userData = &instance;

        instance.callback = callback;

        printf("Parsing: %s\n", fname);
        xmlParseDocument(ctx);
        nvd_sax_clean(&instance);
        p = ctx->myDoc;
        bool good = ctx->wellFormed;
        ctx->sax = old;
        xmlFreeParserCtxt(ctx);
        if (p) {
                xmlFreeDoc(p);
        }
        xmlCleanupParser();
        malloc_trim(0);

        if (!good) {
                fprintf(stderr, "nvd: Badly formed XML file, aborting\n");
        } else {
                printf("Parsed: %s\n", fname);
        }
        return good;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
