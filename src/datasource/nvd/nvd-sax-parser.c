/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE

#include <libxml/SAX2.h>
#include <libxml/parser.h>
#include <libxml/parserInternals.h>
#include <stdbool.h>

#include "nvd.h"

typedef struct NvdSaxParser {
        /** XML traversal state */
        bool in_list;
        bool in_entry;
        bool in_product;
        bool in_summary;
        bool in_reference;

        bool in_link;
        bool in_vuln_cvss;
        bool in_base_metrics;
        bool in_score;
        bool in_vector;
        bool in_date;

        xmlChar *cur_id;
        xmlChar *summary;
        xmlChar *score;
        xmlChar *vector;
        xmlChar *modified;
} NvdSaxParser;

/**
 * Ensure XML is properly initialised
 */
__attribute__((constructor)) static void _nvd_init_(void)
{
        LIBXML_TEST_VERSION
}

static void handle_flip_states(NvdSaxParser *self, const xmlChar *name)
{
        if (xmlStrEqual(name, BAD_CAST "vuln:references")) {
                self->in_link = !self->in_link;
                return;
        }
        if (self->in_link && xmlStrEqual(name, BAD_CAST "vuln:reference")) {
                /* TODO: Handle URIs */
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:vulnerable-software-list")) {
                self->in_list = !self->in_list;
                return;
        }
        if (self->in_list && xmlStrEqual(name, BAD_CAST "vuln:product")) {
                self->in_product = !self->in_product;
                return;
        }
        /* Score checking */
        if (xmlStrEqual(name, BAD_CAST "vuln:cvss")) {
                self->in_vuln_cvss = !self->in_vuln_cvss;
                return;
        }
        if (self->in_vuln_cvss &&
            xmlStrEqual(name, BAD_CAST "cvss:base_metrics")) {
                self->in_base_metrics = !self->in_base_metrics;
                return;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:score")) {
                self->in_score = !self->in_score;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:access-vector")) {
                self->in_vector = !self->in_vector;
        }
        /* Get last modified */
        if (xmlStrEqual(name, BAD_CAST "vuln:last-modified-datetime")) {
                self->in_date = !self->in_date;
        }
        if (self->in_entry && xmlStrEqual(name, BAD_CAST "vuln:summary")) {
                self->in_summary = !self->in_summary;
        }
}

static void start_element(void *udata, const xmlChar *name,
                          __unused__ const xmlChar **attrs)
{
        NvdSaxParser *self = udata;

        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = true;
                return;
        }

        if (!self->in_entry) {
                return;
        }

        handle_flip_states(self, name);
}

static void end_element(void *udata, const xmlChar *name)
{
        NvdSaxParser *self = udata;
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = false;
                /* TODO: Clean up state machine */
                return;
        }
        if (!self->in_entry) {
                return;
        }
        handle_flip_states(self, name);
}

/**
 * Parse an NVD xml database using SAX2 API
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool nvd_sax_parser_load(__unused__ const char *fname)
{
        xmlParserCtxtPtr ctx = NULL;
        xmlSAXHandler handler = { 0 };
        NvdSaxParser instance = { 0 };
        xmlDocPtr p = NULL;
        xmlSAXHandler *old = NULL;
        handler.startElement = start_element;
        handler.endElement = end_element;
        ctx = xmlCreateFileParserCtxt(fname);
        if (!ctx) {
                fprintf(stderr, "nvd: Error creating XML context\n");
                return false;
        }
        old = ctx->sax;
        ctx->sax = &handler;
        ctx->userData = &instance;

        printf("Parsing: %s\n", fname);
        xmlParseDocument(ctx);
        p = ctx->myDoc;
        bool good = ctx->wellFormed;
        ctx->sax = old;
        xmlFreeParserCtxt(ctx);
        if (p) {
                xmlFreeDoc(p);
        }
        xmlCleanupParser();

        if (!good) {
                fprintf(stderr, "nvd: Badly formed XML file, aborting\n");
        } else {
                printf("ParsedL %s\n", fname);
        }
        return good;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
