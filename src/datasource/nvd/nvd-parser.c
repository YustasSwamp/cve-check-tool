/*
 * This file is part of cve-check-tool
 *
 * Copyright Â© 2015-2016 Intel Corporation
 *
 * cve-check-tool is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 */

#define _GNU_SOURCE

#include <fcntl.h>
#include <libxml/xmlreader.h>
#include <malloc.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#include "util.h"
#include "nvd.h"

typedef struct NvdParser {
        /** XML traversal state */
        bool in_list;
        bool in_entry;
        bool in_product;
        bool in_summary;

        bool in_link;
        bool in_vuln_cvss;
        bool in_base_metrics;
        bool in_score;
        bool in_vector;
        bool in_date;

        xmlChar *cur_id;
        xmlChar *summary;
        xmlChar *score;
        xmlChar *vector;
        xmlChar *modified;
} NvdParser;

static inline void _nvd_parser_clean(NvdParser *self)
{
        if (self->score) {
                xmlFree(self->score);
                self->score = NULL;
        }
        if (self->vector) {
                xmlFree(self->vector);
                self->vector = NULL;
        }
        if (self->cur_id) {
                xmlFree(self->cur_id);
                self->cur_id = NULL;
        }
        if (self->summary) {
                xmlFree(self->summary);
                self->summary = NULL;
        }
        if (self->modified) {
                xmlFree(self->modified);
                self->modified = NULL;
        }
}

/**
 * Main iterator for XML parsing
 *
 * @param r A valid xmlTextReaderPtr (open)
 */
static void process_node(NvdParser *self, xmlTextReaderPtr r)
{
        const xmlChar *name = NULL;
        const xmlChar *value = NULL;

        name = xmlTextReaderConstName(r);
        if (!name) {
                return;
        }
        /* New entry */
        if (xmlStrEqual(name, BAD_CAST "entry")) {
                self->in_entry = !self->in_entry;
                if (!self->in_entry) {
                        /* last_mod = parse_xml_date((char*)self->modified); */
                        /* TODO: Push off this parsed item and products */
                        _nvd_parser_clean(self);
                        return;
                }
                if (self->cur_id) {
                        xmlFree(self->cur_id);
                }
                self->cur_id = xmlTextReaderGetAttribute(r, BAD_CAST "id");
                return;
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:references")) {
                self->in_link = !self->in_link;
                return;
        }
        if (self->in_link && xmlStrEqual(name, BAD_CAST "vuln:reference")) {
                /* TODO: Handle URIs */
        }
        if (xmlStrEqual(name, BAD_CAST "vuln:vulnerable-software-list")) {
                self->in_list = !self->in_list;
                return;
        }
        if (self->in_list && xmlStrEqual(name, BAD_CAST "vuln:product")) {
                self->in_product = !self->in_product;
                return;
        }
        /* Score checking */
        if (xmlStrEqual(name, BAD_CAST "vuln:cvss")) {
                self->in_vuln_cvss = !self->in_vuln_cvss;
                return;
        }
        if (self->in_vuln_cvss &&
            xmlStrEqual(name, BAD_CAST "cvss:base_metrics")) {
                self->in_base_metrics = !self->in_base_metrics;
                return;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:score")) {
                self->in_score = !self->in_score;
        }
        if (self->in_base_metrics &&
            xmlStrEqual(name, BAD_CAST "cvss:access-vector")) {
                self->in_vector = !self->in_vector;
        }
        if (self->in_base_metrics && self->in_vector) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->vector = xmlStrdup(value);
        }
        if (self->in_base_metrics && self->in_score) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->score = xmlStrdup(value);
        }
        /* Get last modified */
        if (xmlStrEqual(name, BAD_CAST "vuln:last-modified-datetime")) {
                self->in_date = !self->in_date;
        }
        if (self->in_date) {
                value = xmlTextReaderConstValue(r);
                if (!value) {
                        return;
                }
                self->modified = xmlStrdup(value);
        }
        /* Product checking */
        if (self->in_list && self->in_product) {
                /* TODO: Parse product */
                return;
        }
        if (self->in_entry && xmlStrEqual(name, BAD_CAST "vuln:summary")) {
                self->in_summary = !self->in_summary;
                if (self->in_summary && self->summary) {
                        xmlFree(self->summary);
                        self->summary = NULL;
                }
                return;
        }
        if (self->in_summary) {
                self->summary = xmlTextReaderValue(r);
                return;
        }
}

/**
 * Parse an NVD xml database
 *
 * @param fname Path to the nvd db
 * @return a boolean value, true if the operation succeeded
 */
bool nvd_parser_load(const char *fname)
{
        bool b = false;
        __unused__ int rc;
        NvdParser self = { 0 };

        if (!fname) {
                return false;
        }

        int fd = 0;

        fd = open(fname, O_RDONLY);
        if (fd < 0) {
                return false;
        }
        /* If it fails, it fails */
        rc = posix_fadvise(fd, 0, 0, POSIX_FADV_SEQUENTIAL);

        xmlTextReaderPtr r = xmlReaderForFd(fd, fname, NULL, 0);
        if (!r) {
                close(fd);
                return false;
        }
        int ret;

        printf("Parsing: %s\n", fname);
        while ((ret = xmlTextReaderRead(r)) > 0) {
                process_node(&self, r);
        }
        printf("Parsed: %s\n", fname);
        _nvd_parser_clean(&self);
        b = true;

        malloc_trim(0);

        xmlFreeTextReader(r);
        if (fd) {
                close(fd);
        }

        return b;
}

/*
 * Editor modelines  -  https://www.wireshark.org/tools/modelines.html
 *
 * Local variables:
 * c-basic-offset: 8
 * tab-width: 8
 * indent-tabs-mode: nil
 * End:
 *
 * vi: set shiftwidth=8 tabstop=8 expandtab:
 * :indentSize=8:tabSize=8:noTabs=true:
 */
